from collections import defaultdict

class DisjointSets:
    def __init__(self, n):
        self.parents = [i for i in range(n)]
        self.rank = [1] * n
        self.counts = [1] * n

    def parent(self, x):
        if self.parents[x] == x:
            return x

        self.parents[x] = self.parent(self.parents[x])
        return self.parents[x]

    def union(self, x, y):
        px = self.parent(x)
        py = self.parent(y)

        if px == py:
            return

        if self.rank[px] > self.rank[py]:
            self.parents[py] = self.parents[px]
            self.counts[px] += self.counts[py]
        elif self.rank[px] < self.rank[py]:
            self.parents[px] = self.parents[py]
            self.counts[py] += self.counts[px]
        else:
            self.parents[py] = self.parents[px]
            self.counts[px] += self.counts[py]
            self.rank[px] += 1

    def size(self, x):
        return self.counts[self.parent(x)]


class Solution:
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        disjoint_sets = DisjointSets(N)
        for i in clean:
            for j in clean:
                if graph[i][j] == 1:
                    disjoint_sets.union(i, j)

        spreads = {}
        infected_by = defaultdict(int)
        for u in initial:
            spreads[u] = set()
            for v in clean:
                if graph[u][v] == 1:
                    spreads[u].add(disjoint_sets.parent(v))

            for p in spreads[u]:
                infected_by[p] += 1


        max_spread = -1
        res = -1

        for n, spread in spreads.items():
            cur_spread = 0
            for group in spread:
                if infected_by[group] == 1:
                    cur_spread += disjoint_sets.size(group)

            if cur_spread > max_spread:
                max_spread = cur_spread
                res = n
            elif cur_spread == max_spread:
                res = min(n, res)

        return res


###############################################################
import unittest


class TestFunctions(unittest.TestCase):
    def test_1(self):
        s = Solution()

        self.assertEqual(
            0,
            s.minMalwareSpread(
                [
                    [1, 0, 0, 0, 0, 0, 0, 0, 0], #
                    [0, 1, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 1, 0, 1, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 1, 0, 0, 0, 0], #
                    [0, 0, 0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 1, 0, 0], #
                    [0, 0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 1],
                ],
                [6, 0, 4],
            ),
        )

        self.assertEqual(
            0,
            s.minMalwareSpread(graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]),
        )

        self.assertEqual(
            1,
            s.minMalwareSpread(graph=[[1, 1, 0], [1, 1, 1], [0, 1, 1]], initial=[0, 1]),
        )

        self.assertEqual(
            1,
            s.minMalwareSpread(
                graph=[[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]],
                initial=[0, 1],
            ),
        )


if __name__ == "__main__":
    unittest.main()
